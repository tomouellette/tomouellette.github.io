<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>IP + Bouncing Dots</title>
<style>
  /* Reset & layout */
  html,body { height:100%; margin:0; background:#0f1724; color:#e6eef8; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; }
  #ipBar {
    position:fixed;
    left:12px;
    top:12px;
    z-index:20;
    background: rgba(10,12,18,0.6);
    padding:10px 14px;
    border-radius:10px;
    backdrop-filter: blur(6px);
    box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    display:flex;
    align-items:center;
    gap:10px;
    user-select: text;
  }
  #ipLabel { font-size:13px; color:#9fb3d6; }
  #ipValue { font-weight:600; font-size:15px; color:#eaf6ff; }
  #status { font-size:12px; color:#8fa0b8; margin-left:6px; }
  canvas { display:block; width:100%; height:100%; position:fixed; left:0; top:0; z-index:1; }
  /* small control hint */
  #hint {
    position:fixed; right:12px; bottom:12px; z-index:20;
    font-size:12px; color:#9fb3d6; background:rgba(10,12,18,0.45);
    padding:8px 10px;border-radius:8px;
    backdrop-filter: blur(4px);
  }

  /* Make sure IP bar text doesn't get covered by very small screens */
  @media (max-width:400px) {
    #ipBar { padding:8px 10px; left:8px; top:8px; }
    #ipValue { font-size:13px; }
  }
</style>
</head>
<body>
  <div id="ipBar" role="status" aria-live="polite">
    <div id="ipLabel">Your IP</div>
    <div id="ipValue">—</div>
    <div id="status">(fetching...)</div>
  </div>

  <canvas id="c"></canvas>

  <div id="hint">Click anywhere to add a dot • Hidden tab pauses animation</div>

<script>
/* Show IP */
(async function showIP() {
  const ipEl = document.getElementById('ipValue');
  const st = document.getElementById('status');

  // Two-step attempt: try ipify, fallback to ipinfo.
  const endpoints = [
    'https://api.ipify.org?format=json',
    'https://ipinfo.io/json' // ipinfo usually allows CORS but can be rate-limited
  ];

  for (const url of endpoints) {
    try {
      const resp = await fetch(url, { cache: 'no-store' });
      if (!resp.ok) throw new Error('non-200');
      const j = await resp.json();
      // ipify => { ip: "x.x.x.x" }, ipinfo => { ip: "x.x.x.x", ... }
      const ip = j.ip || j.IP || j.query || null;
      if (ip) {
        ipEl.textContent = ip;
        st.textContent = ''; // clear status
        return;
      }
    } catch (err) {
      // try next endpoint
    }
  }
  // final fallback
  ipEl.textContent = 'Unavailable';
  st.textContent = '(could not fetch IP — network or CORS blocked)';
})();

/* full-viewport canvas bouncing dots */
(function bouncingDots() {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  // handle high DPI screens
  function fitCanvas() {
    const ratio = window.devicePixelRatio || 1;
    const w = window.innerWidth;
    const h = window.innerHeight;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.round(w * ratio);
    canvas.height = Math.round(h * ratio);
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0); // scale drawing to CSS pixels
  }

  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // Particle class
  class Dot {
    constructor(boundsW, boundsH) {
      this.radius = randomRange(3, 11);
      // start inside viewport, avoid being partially outside
      this.x = randomRange(this.radius, boundsW - this.radius);
      this.y = randomRange(this.radius, boundsH - this.radius);
      // velocity: random direction, speed scales with radius (smaller -> faster)
      const speedBase = randomRange(0.9, 2.5);
      const angle = Math.random() * Math.PI * 2;
      this.vx = Math.cos(angle) * speedBase * (10 / this.radius);
      this.vy = Math.sin(angle) * speedBase * (10 / this.radius);
      this.color = randomColor();
      this.id = Math.random().toString(36).slice(2,8);
    }

    step(dt, boundsW, boundsH) {
      // dt in seconds
      this.x += this.vx * dt * 60; // normalize by 60fps so movement is stable
      this.y += this.vy * dt * 60;

      // bounce off edges (reflect)
      if (this.x - this.radius < 0) {
        this.x = this.radius;
        this.vx = Math.abs(this.vx);
      } else if (this.x + this.radius > boundsW) {
        this.x = boundsW - this.radius;
        this.vx = -Math.abs(this.vx);
      }
      if (this.y - this.radius < 0) {
        this.y = this.radius;
        this.vy = Math.abs(this.vy);
      } else if (this.y + this.radius > boundsH) {
        this.y = boundsH - this.radius;
        this.vy = -Math.abs(this.vy);
      }
    }

    draw(ctx) {
      // subtle glow + solid center
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.globalAlpha = 0.28;
      ctx.shadowColor = this.color;
      ctx.shadowBlur = Math.max(6, this.radius * 1.8);
      ctx.arc(this.x, this.y, this.radius * 2.2, 0, Math.PI * 2);
      ctx.fill();

      ctx.beginPath();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function randomRange(a, b) { return a + Math.random() * (b - a); }
  function randomColor() {
    // palette 
    const palettes = [
      [32,187,208], // teal
      [255,138,101], // warm orange
      [164,120,255], // purple
      [88,200,154], // green
      [102,197,255]  // light blue
    ];
    const c = palettes[Math.floor(Math.random()*palettes.length)];
    return `rgb(${c[0]},${c[1]},${c[2]})`;
  }

  // manage particles
  let dots = [];
  function resetDots() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const area = w * h;
    // density factor: one dot per ~16k px by default
    const desiredCount = Math.max(6, Math.min(150, Math.round(area / 16000)));
    // if we already have dots, keep them but adjust if needed
    if (dots.length < desiredCount) {
      for (let i = dots.length; i < desiredCount; i++) dots.push(new Dot(w, h));
    } else if (dots.length > desiredCount) {
      dots = dots.slice(0, desiredCount);
    }
  }

  resetDots();
  window.addEventListener('resize', () => resetDots());

  // animation loop with time-based updates
  let last = performance.now();
  let running = true;
  function frame(now) {
    if (!running) return;
    const dt = Math.min(0.05, (now - last) / 1000); // cap dt to avoid huge steps on tab resuming
    last = now;

    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    // clear with transparent-ish background so page bg shows
    ctx.clearRect(0, 0, w, h);

    // update & draw
    for (const d of dots) {
      d.step(dt, w, h);
      d.draw(ctx);
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Pause when tab is hidden to save CPU
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      running = false;
    } else {
      // resume
      running = true;
      last = performance.now();
      requestAnimationFrame(frame);
    }
  });

  // allow adding dots by clicking
  window.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const newDot = new Dot(canvas.clientWidth, canvas.clientHeight);
    newDot.x = Math.max(newDot.radius, Math.min(canvas.clientWidth - newDot.radius, x));
    newDot.y = Math.max(newDot.radius, Math.min(canvas.clientHeight - newDot.radius, y));
    // give it a slight random velocity so it doesn't stay still
    newDot.vx = (Math.random() - 0.5) * 4;
    newDot.vy = (Math.random() - 0.5) * 4;
    dots.push(newDot);
    // cap maximum to avoid runaway
    if (dots.length > 400) dots.splice(0, dots.length - 400);
  });

  // small performance-friendly redraw when switching DPR or resizing
  window.matchMedia && window.matchMedia('(resolution)').addEventListener?.('change', fitCanvas);
})();
</script>
</body>
</html>
